From ca83b1dafe5e20360221aa15758668fef41a6d64 Mon Sep 17 00:00:00 2001
From: Eduardo Habkost <ehabkost@redhat.com>
Date: Mon, 10 Jan 2011 19:31:44 -0200
Subject: [PATCH] Support underlying UNDI devices that don't support interrupts (v2)

RH-Author: Eduardo Habkost <ehabkost@redhat.com>
Message-id: <1294687904-25409-1-git-send-email-ehabkost@redhat.com>
Patchwork-id: 16080
O-Subject: [RHEL-6 gpxe PATCH] [undi] Support underlying UNDI devices that don't
	support interrupts (v2)
Bugzilla: 661840
RH-Acked-by: Gleb Natapov <gleb@redhat.com>
RH-Acked-by: Alex Williamson <alex.williamson@redhat.com>

Bugzilla: 668005
Upstream status: included on ipxe

Backport of ipxe commit:

commit 006d9f1f60594d6ffd147bea1f08bc753051a50d
Author: Michael Brown <mcb30@ipxe.org>
Date:   Fri Nov 19 18:48:00 2010 +0000

    [undi] Support underlying UNDI devices that don't support interrupts

    Some network cards do not generate interrupts when operated via the
    UNDI API.  Allow for this by waiting for the ISR to be triggered only
    if the PXE stack advertises that it supports interrupts.  When the PXE
    stack does not advertise interrupt support, we skip the call to
    PXENV_UNDI_ISR_IN_START and just poll the device using
    PXENV_UNDI_ISR_IN_PROCESS.  This matches the observed behaviour of at
    least one other PXE NBP (emBoot's winBoot/i), so there is a reasonable
    chance of this working.

    Originally-implemented-by: Muralidhar Appalla <Muralidhar.Appalla@emulex.com>
    Signed-off-by: Michael Brown <mcb30@ipxe.org>

Signed-off-by: Eduardo Habkost <ehabkost@redhat.com>
---
 src/arch/i386/drivers/net/undinet.c |   48 ++++++++++++++++++++++------------
 1 files changed, 31 insertions(+), 17 deletions(-)

Signed-off-by: Eduardo Habkost <ehabkost@raisama.net>
---
 src/arch/i386/drivers/net/undinet.c |   48 ++++++++++++++++++++++------------
 1 files changed, 31 insertions(+), 17 deletions(-)

diff --git a/src/arch/i386/drivers/net/undinet.c b/src/arch/i386/drivers/net/undinet.c
index d6db6f7..7b6c242 100644
--- a/src/arch/i386/drivers/net/undinet.c
+++ b/src/arch/i386/drivers/net/undinet.c
@@ -40,6 +40,8 @@
 
 /** An UNDI NIC */
 struct undi_nic {
+	/** Device supports IRQs */
+	int irq_supported;
 	/** Assigned IRQ number */
 	unsigned int irq;
 	/** Currently processing ISR */
@@ -420,8 +422,10 @@ static void undinet_poll ( struct net_device *netdev ) {
 	int rc;
 
 	if ( ! undinic->isr_processing ) {
-		/* Do nothing unless ISR has been triggered */
-		if ( ! undinet_isr_triggered() ) {
+		/* If interrupts are supported, then do nothing unless
+		 * the ISR has been triggered.
+		 */
+		if ( undinic->irq_supported && ( ! undinet_isr_triggered() ) ){
 			/* Allow interrupt to occur */
 			__asm__ __volatile__ ( REAL_CODE ( "sti\n\t"
 							   "nop\n\t"
@@ -525,10 +529,12 @@ static int undinet_open ( struct net_device *netdev ) {
 	struct s_PXENV_UNDI_OPEN undi_open;
 	int rc;
 
-	/* Hook interrupt service routine and enable interrupt */
-	undinet_hook_isr ( undinic->irq );
-	enable_irq ( undinic->irq );
-	send_eoi ( undinic->irq );
+	/* Hook interrupt service routine and enable interrupt if supported */
+	if ( undinic->irq_supported ) {
+		undinet_hook_isr ( undinic->irq );
+		enable_irq ( undinic->irq );
+		send_eoi ( undinic->irq );
+	}
 
 	/* Set station address.  Required for some PXE stacks; will
 	 * spuriously fail on others.  Ignore failures.  We only ever
@@ -592,9 +598,11 @@ static void undinet_close ( struct net_device *netdev ) {
 	undinet_call ( undinic, PXENV_UNDI_CLOSE, &undi_close,
 		       sizeof ( undi_close ) );
 
-	/* Disable interrupt and unhook ISR */
-	disable_irq ( undinic->irq );
-	undinet_unhook_isr ( undinic->irq );
+	/* Disable interrupt and unhook ISR if supported */
+	if ( undinic->irq_supported ) {
+		disable_irq ( undinic->irq );
+		undinet_unhook_isr ( undinic->irq );
+	}
 
 	DBGC ( undinic, "UNDINIC %p closed\n", undinic );
 }
@@ -690,13 +698,8 @@ int undinet_probe ( struct undi_device *undi ) {
 		goto err_undi_get_information;
 	memcpy ( netdev->ll_addr, undi_info.PermNodeAddress, ETH_ALEN );
 	undinic->irq = undi_info.IntNumber;
-	if ( undinic->irq > IRQ_MAX ) {
-		DBGC ( undinic, "UNDINIC %p invalid IRQ %d\n",
-		       undinic, undinic->irq );
-		goto err_bad_irq;
-	}
-	DBGC ( undinic, "UNDINIC %p is %s on IRQ %d\n",
-	       undinic, eth_ntoa ( netdev->ll_addr ), undinic->irq );
+	DBGC ( undinic, "UNDINIC %p has MAC address %s\n",
+	       undinic, eth_ntoa ( netdev->hw_addr ) );
 
 	/* Get interface information */
 	memset ( &undi_iface, 0, sizeof ( undi_iface ) );
@@ -706,6 +709,17 @@ int undinet_probe ( struct undi_device *undi ) {
 		goto err_undi_get_iface_info;
 	DBGC ( undinic, "UNDINIC %p has type %s and link speed %d\n",
 	       undinic, undi_iface.IfaceType, undi_iface.LinkSpeed );
+	if ( undi_iface.ServiceFlags & SUPPORTED_IRQ ) {
+		if ( undinic->irq > IRQ_MAX ) {
+			DBGC ( undinic, "UNDINIC %p has invalid IRQ %d\n",
+			       undinic, undinic->irq );
+			rc = -EINVAL;
+			goto err_bad_irq;
+		}
+		undinic->irq_supported = 1;
+		DBGC ( undinic, "UNDINIC %p uses IRQ %d\n",
+		       undinic, undinic->irq );
+	}
 	if ( strncmp ( ( ( char * ) undi_iface.IfaceType ), "Etherboot",
 		       sizeof ( undi_iface.IfaceType ) ) == 0 ) {
 		DBGC ( undinic, "UNDINIC %p Etherboot 5.4 workaround enabled\n",
@@ -724,8 +738,8 @@ int undinet_probe ( struct undi_device *undi ) {
 	return 0;
 
  err_register:
- err_undi_get_iface_info:
  err_bad_irq:
+ err_undi_get_iface_info:
  err_undi_get_information:
  err_undi_initialize:
 	/* Shut down UNDI stack */
-- 
1.7.3.2

